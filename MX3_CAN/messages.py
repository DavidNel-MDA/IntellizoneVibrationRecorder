import can
from MX3_CAN.config_yaml import MODULE_TYPE

class SendMessage:
    def __init__(
        self,
        message_type: int,
        node_id: int,
        module_type: int = MODULE_TYPE["Status_Screen"],
        dest_module: int = MODULE_TYPE["Controller"],
        dest_node: int = 0x0,
        direction: str = "tx",
    ) -> None:
        """
        Construct a MatrixCAN-format message sender or receiver.

        Parameters
        ----------
        message_type : int
            High 16 bits of arbitration ID.
        node_id : int
            Local device's node ID.
        module_type : int, optional
            Local device's module type (default is Status_Screen).
        dest_module : int, optional
            Remote device's module type (default is Controller).
        dest_node : int, optional
            Remote device's node ID (default is 0x0).
        direction : str, optional
            "tx" for sending, "rx" for receiving from controller (default: "tx").

        Returns
        -------
        None
        """
        # Store the parameters as instance variables
        self.message_type = message_type
        self.node_id = node_id
        self.module_type = module_type
        self.dest_module = dest_module
        self.dest_node = dest_node
        self.direction = direction

    def build_arbitration_id(self) -> int:
        """
        Construct a MatrixCAN arbitration ID for this message.

        Returns
        -------
        int
            The constructed arbitration ID.

        The arbitration ID is constructed differently depending on whether this
        message is being sent or received.

        If self.direction is "tx", the arbitration ID is constructed as follows:

        * High 16 bits: `message_type` (int)
        * Bits 15-12: `module_type` (int)
        * Bits 11-8: `node_id` (int)
        * Bits 7-4: `dest_module` (int)
        * Bits 3-0: `dest_node` (int)

        If self.direction is "rx", the arbitration ID is constructed as follows:

        * High 16 bits: `message_type` (int)
        * Bits 15-12: `dest_module` (source module is the "remote", int)
        * Bits 11-8: `dest_node` (int)
        * Bits 7-4: `module_type` (our device, int)
        * Bits 3-0: `node_id` (int)
        """
        if self.direction == "tx":
            return (
                (self.message_type << 16) |
                (self.module_type << 12) |
                (self.node_id << 8) |
                (self.dest_module << 4) |
                self.dest_node
            )
        elif self.direction == "rx":
            return (
                (self.message_type << 16) |
                (self.dest_module << 12) |
                (self.dest_node << 8) |
                (self.module_type << 4) |
                self.node_id
            )
        else:
            raise ValueError(f"Invalid direction: {self.direction}")

    def build_message(self, data: list[int] | None = None) -> can.Message:
        """
        Construct a CAN message with the arbitration ID generated by
        `build_arbitration_id()` and optional data.

        Parameters
        ----------
        data : list[int], optional
            The data bytes to include in the message. If not provided, an empty
            list is used.

        Returns
        -------
        can.Message
            The constructed CAN message.
        """
        arbitration_id = self.build_arbitration_id()
        message_data = data if data is not None else []

        # Build the message using the constructed arbitration ID and optional data
        return can.Message(
            arbitration_id=arbitration_id,
            data=message_data,
            is_extended_id=True  # This is a MatrixCAN message
        )

    def send_once(self, bus: can.BusABC, data: list[int] | None = None) -> can.Message | None:
        """
        Send the message once on the CAN bus.

        Parameters
        ----------
        bus : can.Bus
            The CAN bus to send on.
        data : list of int, optional
            The data bytes to include in the message. If not provided, an empty
            list is used.

        Returns
        -------
        can.Message or None
            The sent message, or None if the send failed.
        """
        # Build the CAN message
        message = self.build_message(data)

        # Attempt to send the message on the CAN bus
        try:
            bus.send(message)
            return message
        except can.CanError as error:
            # If the send fails, return None
            return None

    def send_periodic(
        self,
        canbus: can.BusABC,
        data: list[int] | None = None,
        period: float = 0.2
    ):
        """
        Start sending the message at a periodic rate on the CAN bus.

        Parameters
        ----------
        canbus : can.BusABC
            The CAN bus to send on.
        data : list of int, optional
            The data bytes to include in the message. If not provided, an empty
            list is used.
        period : float, optional
            The period in seconds at which the message should be sent (default
            is 0.2).

        Returns
        -------
        can.AsyncBufferedSendTask or None
            The periodic sender task handle, or None if the send failed.
        """
        # Build the CAN message
        message = self.build_message(data or [])

        # Attempt to start sending the message at the specified period
        try:
            # Return the periodic sender task handle
            return canbus.send_periodic(message, period)
        except can.CanError:
            # If the send fails, return None
            return None
